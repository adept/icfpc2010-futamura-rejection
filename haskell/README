Какие есть утилиты и как ими пользоваться:

gate-bruteforce:
================
  Автоподбор таблицы переходов гейта на основании данных, полученных от
  сервера.

key-bruteforce:
===============
  Брутфорс фабрики, выдающей указанную последовательность.

  Вписать целевую последовательность в исходник вместо "key = ..."
  Вписать ожидаемую входную последовательность там же вместо "inp = ..."

  Запускать как ./key-bruteforce N M, где N - кол-во параллельно
  запускаемых инстансов, M - номер этого инстанса (с нуля).

  Для брутфорса на одной машине - ./key_bruteforce 1 0

  Реально можно брутфорсить фабрики размером не более 6 гейтов.

concatfac:
==========
  ./concatfac wire1 wire2 wire3 ...
  , где wire* - файлы в wire-формате

  Склеит указанные factory в порядке перечисления, переведет
  в формат, приемлемый для организаторов, и выдаст на stdout

cardump:
========
  ./cardump car_data
  В файле - данные по машинам, одна машина на строку, формат строки: "id, trits".
  Декодирует и выдаст haskell data structures (для чтения глазами) на
  stdout.

car2solver:
===========
  Преобразует машину в уравнения, которые можно скармливать в Matlab и
  Mathematica. 

  ./car2solver < car_data
  С stdin - данные по одной машине.
  Выдаст ее в виде уравнений "AAA - BBB > 0" на stdout

fuel-bruteforce:
================
  ./fuel_bruteforce < car.def
  С stdin - данные по одной машине.
  На stdout - топливо со скалярными компонентами для нее (если это возможно).
  Если невозможно - завершится с ненулевым кодом возврата.
  Само определяет объем пространства перебора исходя из размеров
  машины (чтобы долго не тормозить и не жрать память)

apply-fuel:
==========
  Показывает результат заправки автомобиля топливом.
  Запускать в директории с car.def и car.fuel_formula - оно само их
  считает и покажет, какой результат будет в каждой камере.
  Использовалась для отладки брутфорсера топлив.

encode-fuel:
============
   ./encode_fuel < fuel > trits
   С stdin - описание топлива в виде "[[[2]],[[1]]]"
   На stdout - последовательность trits, перед которой уже приклеен ключ

encode-car:
============
   ./encode-car < car > trits
   С stdin - описание машины в виде кучи строк:
     4 -> id maшины (просто так, чтобы было)
     2 -> кол-во баков
     [1,0,1,1,0] -> какого типа камеры (в примере их 5, вторая и пятая
                    - auxillary)
     [1,0,1,0,1,1] -> верхняя труба камеры 0
     [0,0,1,1]     -> нижняя труба камеры 0
     ....
     по две строки на камеру
     ....

   Перебирает возможные варианты кодирования машины, и выдает
   минимальный на stdout.
   Кроме того, выдает дамп Haskell-структуры, которая получилась после
   перебора.
